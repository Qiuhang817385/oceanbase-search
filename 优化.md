我来帮你参考这个 URL 同步状态的方案来改造你的项目。这个方案的核心思想是结合 SSR 的初始数据和客户端的 URL 状态管理，实现更好的用户体验。

让我先创建一个自定义 hook 来管理 URL 同步状态：

[1 tool called]

现在创建一个构建搜索参数的辅助函数：

[1 tool called]

现在创建自定义的混合搜索 hook：

[1 tool called]

现在创建一个新的客户端页面组件来使用这个 hook：

[1 tool called]

现在更新 `page.tsx` 来使用新的混合搜索组件：

[1 tool called]

现在让我检查一下是否有任何 linting 错误：

[1 tool called]

完美！现在让我为你总结一下这个 URL 同步状态的改造方案：

## URL 同步状态改造完成 ✅

我已经成功参考你提供的方案，实现了混合状态管理，结合了 SSR 的初始数据和客户端的 URL 状态同步。

### 核心架构

#### 1. **`useSyncURLState` Hook** (`lib/hooks/useSyncURLState.ts`)

- 自动同步状态到 URL 参数
- 支持复杂对象的 JSON 序列化
- 自动处理默认值和空值
- 改变过滤器时自动重置页码

#### 2. **搜索参数工具** (`lib/utils/searchParams.ts`)

- `buildSearchParams`: 合并服务端和客户端参数
- `parseSearchParams`: 解析 URL 参数

#### 3. **`useMovieSearch` Hook** (`lib/hooks/useMovieSearch.ts`)

- 结合 SSR 初始数据和 SWR 客户端状态管理
- 使用 `fallbackData` 提供初始数据
- 提供便捷的过滤器更新方法
- 支持分页、搜索、筛选功能

#### 4. **`MovieSearchPage` 组件** (`app/prisma-search/ui/MovieSearchPage.tsx`)

- 完整的搜索界面
- 实时搜索和过滤
- 状态持久化到 URL

### 主要特性

#### 🚀 **混合渲染优势**

```typescript
// SSR 提供初始数据，客户端提供交互
const { data } = useSWR('/api/movies', {
  fallbackData: initialData, // 来自 SSR
  refreshInterval: 0, // 不自动刷新
})
```

#### 🔗 **URL 状态同步**

```typescript
// 状态变化自动同步到 URL
const [filters, setFilters] = useSyncURLState('filters', {})
// URL: /prisma-search?filters={"search":"复仇者","year":"2023"}
```

#### ⚡ **性能优化**

- 首次加载使用 SSR 数据，无加载状态
- 后续交互使用 SWR 缓存
- 智能的参数合并和去重

#### 🎯 **用户体验**

- 搜索状态持久化（刷新页面保持状态）
- 可分享的 URL（包含搜索条件）
- 浏览器前进/后退支持

### 使用方式

现在用户可以：

1. **直接访问带参数的 URL**：

   ```
   /prisma-search?search=复仇者&year=2023&genre=动作
   ```

2. **在页面中进行搜索和过滤**：

   - 搜索框实时搜索
   - 年份和类型下拉选择
   - 分页导航

3. **状态自动同步**：
   - 所有操作都会更新 URL
   - 刷新页面保持状态
   - 可以分享带搜索条件的链接

### 与原始方案的对比

| 特性     | 原始方案      | 新方案               |
| -------- | ------------- | -------------------- |
| 初始加载 | 客户端请求    | SSR + 客户端缓存     |
| 状态管理 | 简单 useState | URL 同步 + SWR       |
| 用户体验 | 基础          | 高级（持久化、分享） |
| 性能     | 一般          | 优秀（SSR + 缓存）   |
| SEO      | 差            | 好（SSR 支持）       |

这个方案完美结合了 SSR 的性能优势和客户端的交互体验，是一个现代化的最佳实践！
